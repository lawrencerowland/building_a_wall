<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Galois Adjoints</title>
  <link rel="stylesheet" href="../common.css" />
</head>
<body>
  <div class="page">
    <nav class="site-nav">
      <a href="../index.html">Home</a>
      <a href="../projects/">Projects</a>
      <a href="../sandbox/">Galois Adjoints</a>
      <a href="../ai-tools/">AI Tools</a>
      <a href="../systems/">Systems Thinking</a>
      <a href="../lifecycle/">Lifecycle</a>
      <a href="../insights/">Insights</a>
    </nav>
    <main class="section">
      <h1>Galois Adjoints</h1>
      <p>A practical way to use Galois adjoints (poset adjunctions) in project management is to treat them as a bidirectional translation layer between what you promise and what you must resource.</p>
    </main>

    <section class="section">
      <h2>Translation layer</h2>
      <ul>
        <li><strong>Requirements space</strong>: what you want to be true and what you promise.</li>
        <li><strong>Commitments space</strong>: what you must resource, approve, procure, schedule, and mitigate.</li>
      </ul>
      <p>You get two monotone maps that “fit” each other exactly via the adjunction law.</p>
    </section>

    <section class="section">
      <h2>Core move: define one map, derive the other</h2>
      <p><strong>Let</strong> P be requirements ordered from easier → harder, and Q be commitments ordered from weaker → stronger (more budget, more time, higher technical scope, higher regulatory readiness, and so on).</p>
      <p><strong>Left adjoint</strong> <code>f : Requirements → Commitments</code> maps a requirement to the weakest commitment package that still guarantees it.</p>
      <p><strong>Right adjoint</strong> <code>g : Commitments → Requirements</code> maps a commitment package to the strongest requirement level you can safely claim.</p>
    </section>

    <section class="section">
      <h2>Governance test (adjunction law)</h2>
      <p>Your plan/commitment <code>c</code> is sufficient for requirement <code>r</code> iff:</p>
      <ul>
        <li>It dominates the weakest commitment <code>f(r)</code>, so <code>f(r) ⪯ c</code>.</li>
        <li>The requirement sits below what you can safely guarantee, so <code>r ⪯ g(c)</code>.</li>
      </ul>
    </section>

    <section class="section">
      <h2>Where this plugs into monotone co-design thinking</h2>
      <p>Project management lives on trade-offs (performance/scope vs schedule vs cost vs risk). A Galois adjoint gives you a disciplined way to ask:</p>
      <ul>
        <li>“If stakeholders push capacity up one notch, what is the minimum non-decreasing uplift I must impose on signalling, approvals, budget, schedule, or risk controls?”</li>
        <li>“If Treasury caps budget, what’s the strongest deliverable we can still honestly commit to?”</li>
      </ul>
      <p>Feasibility is encoded as inequalities like <code>r ⪯ g(c)</code> or <code>f(r) ⪯ c</code>.</p>
    </section>

    <section class="section">
      <h2>Critical realism: adjoints exist only if “weakest” exists</h2>
      <p>In real project trade-offs, a minimum commitment is often not unique (classic Pareto trade-off: buy time with money or money with time). That’s why solutions are often antichains (Pareto fronts), not a single least element.</p>
      <ul>
        <li>Use a Galois adjoint when governance forces a single policy-defined notion of “weakest” (like a stage-gate package or a unified budget/schedule index).</li>
        <li>Use MCDP-style set-valued answers when you want to preserve genuine trade-offs (solutions as upper sets or antichains).</li>
      </ul>
    </section>
  </div>
</body>
</html>
