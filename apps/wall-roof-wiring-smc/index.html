<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Wiring diagram: Build a wall, then put a roof on (SMC / wiring-operad view)</title>
  <link rel="stylesheet" href="../../common.css" />
  <style>
    :root{
      --bg:#0b0f14; --panel:#0f1620; --panel2:#111b27; --ink:#e8eef6; --muted:#a6b2c3;
      --accent:#6ee7ff; --accent2:#a78bfa; --good:#34d399; --bad:#fb7185; --warn:#fbbf24;
      --wire:#94a3b8; --wireHi:#e2e8f0; --box:#121a25; --boxHi:#1a2636;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
      --shadow: 0 10px 30px rgba(0,0,0,.35);
      --radius: 12px;
    }
    *{box-sizing:border-box}
    body{
      margin:0; font-family:var(--sans); color:var(--ink); background:radial-gradient(1200px 700px at 20% 10%, #152033 0%, var(--bg) 60%);
      line-height:1.35;
    }
    header{
      padding:22px 22px 10px 22px;
    }
    header h1{ margin:0 0 6px 0; font-weight:700; font-size:18px; letter-spacing:.2px;}
    header p{ margin:0; color:var(--muted); font-size:13px; max-width:1100px;}
    .grid{
      display:grid;
      grid-template-columns: 1.25fr .85fr;
      gap:14px;
      padding:12px 14px 18px 14px;
      align-items:start;
    }
    .card{
      background:linear-gradient(180deg, rgba(255,255,255,.03), rgba(255,255,255,.015));
      border:1px solid rgba(148,163,184,.18);
      border-radius:var(--radius);
      box-shadow:var(--shadow);
      overflow:hidden;
    }
    .card .hd{
      padding:12px 14px;
      background:rgba(15,22,32,.55);
      border-bottom:1px solid rgba(148,163,184,.14);
      display:flex; align-items:center; justify-content:space-between; gap:10px;
    }
    .hd .title{font-size:13px; font-weight:700; letter-spacing:.2px;}
    .pill{
      font-family:var(--mono);
      font-size:11px;
      padding:4px 8px;
      border-radius:999px;
      border:1px solid rgba(148,163,184,.22);
      background:rgba(17,27,39,.55);
      color:var(--muted);
      white-space:nowrap;
    }
    .pill.good{color:#d1fae5; border-color:rgba(52,211,153,.35); background:rgba(52,211,153,.12)}
    .pill.bad{color:#ffe4e6; border-color:rgba(251,113,133,.45); background:rgba(251,113,133,.12)}
    .pill.warn{color:#fffbeb; border-color:rgba(251,191,36,.55); background:rgba(251,191,36,.12)}
    .body{padding:14px}
    .row{display:flex; gap:10px; flex-wrap:wrap}
    .btn{
      border:1px solid rgba(148,163,184,.22);
      background:rgba(17,27,39,.55);
      color:var(--ink);
      padding:8px 10px;
      border-radius:10px;
      font-size:12px;
      cursor:pointer;
      user-select:none;
    }
    .btn:hover{background:rgba(17,27,39,.78)}
    .btn:active{transform:translateY(1px)}
    .btn.on{border-color:rgba(110,231,255,.55); box-shadow:0 0 0 2px rgba(110,231,255,.12) inset}
    .split{
      display:grid;
      grid-template-columns: 1fr;
      gap:10px;
    }
    .k{
      font-family:var(--mono);
      font-size:12px;
      color:#cbd5e1;
      background:rgba(2,6,23,.35);
      border:1px solid rgba(148,163,184,.16);
      border-radius:12px;
      padding:10px;
      overflow:auto;
      max-height:360px;
    }
    .k strong{color:#e2e8f0}
    .note{ color:var(--muted); font-size:12px; }
    .legend{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:8px;
      margin-top:10px;
    }
    .tag{
      font-size:11px; font-family:var(--mono);
      border:1px solid rgba(148,163,184,.18);
      border-radius:999px;
      padding:5px 8px;
      color:#cbd5e1;
      background:rgba(2,6,23,.25);
      display:flex; align-items:center; gap:8px;
    }
    .dot{
      width:8px;height:8px;border-radius:50%;
      background:var(--wire);
      box-shadow:0 0 0 2px rgba(148,163,184,.12);
    }
    .dot.ac{background:var(--accent); box-shadow:0 0 0 2px rgba(110,231,255,.18)}
    .dot.ac2{background:var(--accent2); box-shadow:0 0 0 2px rgba(167,139,250,.18)}
    .dot.good{background:var(--good); box-shadow:0 0 0 2px rgba(52,211,153,.18)}
    .dot.bad{background:var(--bad); box-shadow:0 0 0 2px rgba(251,113,133,.18)}
    .small{font-size:11px;color:var(--muted)}
    .twoCol{
      display:grid; grid-template-columns: 1fr 1fr; gap:10px;
    }
    .hr{height:1px; background:rgba(148,163,184,.14); margin:12px 0;}
    /* SVG */
    svg{width:100%; height:auto; display:block; background:linear-gradient(180deg, rgba(2,6,23,.15), rgba(2,6,23,.35));}
    .box{fill:var(--box); stroke:rgba(148,163,184,.30); stroke-width:1.2;}
    .box.selected{fill:var(--boxHi); stroke:rgba(110,231,255,.65); stroke-width:1.6;}
    .boxtxt{font-size:13px; fill:var(--ink); font-weight:700;}
    .porttxt{font-size:11px; fill:#cbd5e1; font-family:var(--mono);}
    .wire{fill:none; stroke:rgba(148,163,184,.75); stroke-width:1.5;}
    .wire.dim{stroke:rgba(148,163,184,.22)}
    .wire.hi{stroke:rgba(226,232,240,.92); stroke-width:2.2;}
    .wire.bad{stroke:rgba(251,113,133,.85)}
    .wire.good{stroke:rgba(52,211,153,.85)}
    .wire.ac{stroke:rgba(110,231,255,.85)}
    .wire.ac2{stroke:rgba(167,139,250,.85)}
    .nodeLabel{font-size:12px; fill:#cbd5e1; font-family:var(--mono);}
    .badge{font-size:10px; fill:#0b1220;}
    .badgeBg{fill:rgba(110,231,255,.85);}
    .badgeBg2{fill:rgba(167,139,250,.85);}
    .badgeBgG{fill:rgba(52,211,153,.85);}
    .badgeBgB{fill:rgba(251,113,133,.85);}
    .outerPort{fill:#0b1220; stroke:rgba(148,163,184,.25); stroke-width:1;}
    .outerPortTxt{font-size:11px; fill:#cbd5e1; font-family:var(--mono);}
    .footer{padding:0 14px 18px 14px; color:var(--muted); font-size:12px;}
    a{color:#8be9fd; text-decoration:none}
    a:hover{text-decoration:underline}
    .back-link{padding:0 22px 8px 22px; font-size:12px; color:var(--muted);}
    @media (max-width: 980px){
      .grid{grid-template-columns:1fr}
    }
  </style>
</head>
<body>
<header>
  <h1>Wall ‚Üí Roof: a tiny ‚Äúproject-scope‚Äù wiring diagram, with explicit categorical semantics</h1>
  <p>
    Read left-to-right: wires are typed resources (materials, labour, documents), boxes are processes (morphisms), and the entire picture is a single <em>acyclic</em> wiring term whose semantics is determined by your chosen symmetric monoidal category (SMC) of ‚Äúresource behaviour‚Äù. The demo checks port-typing, visualizes how document-like resources (e.g. drawings) can be threaded through without being ‚Äúconsumed‚Äù, and attaches a small assume/guarantee-style contract to each box so you can sanity-check the physical preconditions and scope-relevant residues as you compose.
  </p>
</header>
<div class="back-link"><a href="../../index.html">Back to app index</a></div>

<div class="grid">
  <section class="card">
    <div class="hd">
      <div class="title">Diagram (SVG) ‚Äî click a box, hover wires</div>
      <div id="typecheckPill" class="pill">Typecheck: ‚Ä¶</div>
    </div>
    <div class="body" style="padding:0">
      <svg id="viz" viewBox="0 0 1120 520" role="img" aria-label="Wiring diagram for building a wall then putting a roof on">
        <defs>
          <marker id="arrow" markerWidth="10" markerHeight="10" refX="8" refY="3" orient="auto" markerUnits="strokeWidth">
            <path d="M0,0 L9,3 L0,6 z" fill="rgba(226,232,240,.9)"></path>
          </marker>
        </defs>
      </svg>
    </div>
  </section>

  <aside class="card">
    <div class="hd">
      <div class="title">Inspector</div>
      <div class="row">
        <button class="btn on" id="btnContracts">Contracts</button>
        <button class="btn on" id="btnTypes">Types</button>
        <button class="btn" id="btnFormal">Formalism</button>
      </div>
    </div>
    <div class="body split">
      <div id="inspector"></div>
      <div class="hr"></div>
      <div class="twoCol">
        <div>
          <div class="small">Legend</div>
          <div class="legend">
            <div class="tag"><span class="dot"></span> material/labour wire</div>
            <div class="tag"><span class="dot ac"></span> ‚Äúinfo-ish‚Äù wire (document)</div>
            <div class="tag"><span class="dot ac2"></span> contract annotation</div>
            <div class="tag"><span class="dot good"></span> satisfied / OK</div>
          </div>
        </div>
        <div>
          <div class="small">Validity conditions (what we check)</div>
          <div class="k" style="max-height:160px">
            <strong>(i) Typing</strong>: every wire‚Äôs type matches its port type.<br/>
            <strong>(ii) Progress / acyclicity</strong>: boxes admit a partial order (no cyclic causal dependence).<br/>
            <strong>(iii) Contract discipline</strong>: each box carries a pre/post ‚Äúcontract‚Äù; the composite contract quantifies away internal wires.<br/>
          </div>
        </div>
      </div>
      <div class="note">
        Tip: click <span style="font-family:var(--mono)">Wall</span> then <span style="font-family:var(--mono)">Roof</span> and watch the ‚ÄúWall‚Äù resource wire.
      </div>
    </div>
  </aside>
</div>

<div class="grid" style="padding-top:0">
  <section class="card">
    <div class="hd">
      <div class="title">Under the picture: a concrete ‚Äúwiring term‚Äù + a semantic reading</div>
      <div class="pill">Wiring-operad ‚Üí SMC (algebra) ‚Üí composite morphism</div>
    </div>
    <div class="body">
      <div class="k" id="formalBlock"></div>
      <div class="note" style="margin-top:10px">
        The point of using an operad of (acyclic) wiring diagrams is that substitution/nesting is <em>the</em> composition rule; your SMC‚Äôs interchange laws hold ‚Äúfor free‚Äù at the diagram level, giving a near-normal form for computation and verification.
      </div>
    </div>
  </section>

  <section class="card">
    <div class="hd">
      <div class="title">Port-level wiring table (the ‚Äúfin/fout‚Äù content, human-readable)</div>
      <div class="pill">Each input port is sourced from either an external input or an upstream output</div>
    </div>
    <div class="body">
      <div class="k" id="wiringTable"></div>
      <div class="note" style="margin-top:8px">
        This table is the same information as the picture; it‚Äôs what you‚Äôd feed to a checker (or compile into <span style="font-family:var(--mono)">(f_in,f_out)</span> in the Bakirtzis‚ÄìVasilakopoulou‚ÄìFleming ‚ÄúW category‚Äù style).
      </div>
    </div>
  </section>
</div>

<div class="footer">
  Self-contained HTML (no external libraries). If you want: I can also emit this same diagram as Catlab-style data (<span style="font-family:var(--mono)">WiringDiagram + Boxes + Wires</span>) to make ‚Äúocompose / oapply‚Äù executable.
</div>

<script>
/**
 * Data model
 * - types: "object-types" in your SMC of resources (materials vs information).
 * - boxes: "processes" (morphisms) with typed input/output ports and contracts (assume/guarantee).
 * - wires: typed connections. Any mismatch is an error (this is the minimal "mathematical validity").
 */
const TYPES = {
  BL: {name:"BL", desc:"Bricklayer (labour)", flavor:"material"},
  S:  {name:"S",  desc:"Sand", flavor:"material"},
  C:  {name:"C",  desc:"Cement", flavor:"material"},
  H2O:{name:"W",  desc:"Water", flavor:"material"},
  M:  {name:"M",  desc:"Mortar", flavor:"material"},
  P:  {name:"P",  desc:"Peg & line kit", flavor:"material"},
  D:  {name:"D",  desc:"Design drawing (document)", flavor:"info"},
  L:  {name:"L",  desc:"Set-out line (pegged out)", flavor:"material"},
  B:  {name:"B",  desc:"Bricks", flavor:"material"},
  Lin:{name:"Lin",desc:"Lintels", flavor:"material"},
  Wall:{name:"Wall",desc:"Wall section (plumbed & laid)", flavor:"material"},
  Tr:{name:"Tr", desc:"Trusses", flavor:"material"},
  RM:{name:"RM", desc:"Roofing material", flavor:"material"},
  F: {name:"F",  desc:"Fasteners", flavor:"material"},
  Sc:{name:"Sc", desc:"Scaffold / access", flavor:"material"},
  Roofed:{name:"Roofed", desc:"Roofed wall (weatherproof shell)", flavor:"material"},
};

const BOXES = [
  {
    id:"mix", label:"Mix mortar", x:260, y:110, w:160, h:110,
    inputs:[["bl_m","BL"],["sand","S"],["cement","C"],["water","H2O"]],
    outputs:[["bl_m_out","BL"],["mortar","M"]],
    contract:{
      assume:["Inputs available on-site.", "Weather allows mixing (no freezing)."],
      guarantee:["Produces mortar M with target consistency (slump / workable).", "Returns bricklayer BL."]
    }
  },
  {
    id:"set", label:"Set out line", x:260, y:290, w:160, h:110,
    inputs:[["bl","BL"],["pegkit","P"],["drawing","D"]],
    outputs:[["bl_out","BL"],["line","L"],["pegkit_out","P"],["drawing_out","D"]],
    contract:{
      assume:["Drawing D specifies wall location & dimensions.", "Peg & line kit P is complete."],
      guarantee:["Establishes line L within tolerance (level/straight).", "Returns P and D unchanged."]
    }
  },
  {
    id:"wall", label:"Build wall", x:540, y:200, w:170, h:140,
    inputs:[["bl_w","BL"],["bricks","B"],["lintels","Lin"],["mortar_in","M"],["line_in","L"],["peg_in","P"],["draw_in","D"]],
    outputs:[["bl_w_out","BL"],["wall_out","Wall"],["peg_out","P"],["draw_out","D"]],
    contract:{
      assume:["Mortar M workable (open time not exceeded).", "Line L in place.", "Materials B & Lin match drawing D."],
      guarantee:["Outputs Wall plumb/level within tolerance.", "Returns BL, P, and D."]
    }
  },
  {
    id:"roof", label:"Put roof on", x:840, y:200, w:190, h:140,
    inputs:[["bl_r","BL"],["wall_in","Wall"],["trusses","Tr"],["roofmat","RM"],["fasteners","F"],["scaffold","Sc"],["draw2","D"]],
    outputs:[["bl_r_out","BL"],["roofed","Roofed"],["scaffold_out","Sc"],["draw2_out","D"]],
    contract:{
      assume:["Wall is cured enough for load transfer & fixing.", "Trusses Tr fit the wall geometry.", "Scaffold Sc safe/inspected."],
      guarantee:["Outputs Roofed (weatherproof shell) meeting drawing D.", "Returns scaffold and drawing."]
    }
  }
];

// External ports (overall interface of the composite process).
const OUTER = {
  in: [
    ["BLm","BL"],["S","S"],["C","C"],["W","H2O"],
    ["BL","BL"],["P","P"],["D","D"],
    ["B","B"],["Lin","Lin"],
    ["Tr","Tr"],["RM","RM"],["F","F"],["Sc","Sc"]
  ],
  out: [
    ["Roofed","Roofed"],
    ["BLm","BL"],["BL","BL"],
    ["P","P"],["D","D"],["Sc","Sc"]
  ]
};

// Wires: (srcKind, srcId, srcPort) -> (tgtKind, tgtId, tgtPort)
const WIRES = [
  // Outer -> Mix
  {id:"w_in_blm", type:"BL", from:["IN","BLm"], to:["mix","bl_m"]},
  {id:"w_in_s",   type:"S",  from:["IN","S"],   to:["mix","sand"]},
  {id:"w_in_c",   type:"C",  from:["IN","C"],   to:["mix","cement"]},
  {id:"w_in_w",   type:"H2O",from:["IN","W"],   to:["mix","water"]},

  // Outer -> Set
  {id:"w_in_bl",  type:"BL", from:["IN","BL"],  to:["set","bl"]},
  {id:"w_in_p",   type:"P",  from:["IN","P"],   to:["set","pegkit"]},
  {id:"w_in_d",   type:"D",  from:["IN","D"],   to:["set","drawing"], flavor:"info"},

  // Mix -> Wall (mortars)
  {id:"w_mortar", type:"M",  from:["mix","mortar"], to:["wall","mortar_in"]},
  // Set -> Wall (line, peg, drawing, labour)
  {id:"w_line",   type:"L",  from:["set","line"], to:["wall","line_in"]},
  {id:"w_peg",    type:"P",  from:["set","pegkit_out"], to:["wall","peg_in"]},
  {id:"w_d1",     type:"D",  from:["set","drawing_out"], to:["wall","draw_in"], flavor:"info"},
  {id:"w_bl2",    type:"BL", from:["set","bl_out"], to:["wall","bl_w"]},

  // Outer -> Wall (bricks + lintels)
  {id:"w_bricks", type:"B",  from:["IN","B"], to:["wall","bricks"]},
  {id:"w_lintels",type:"Lin",from:["IN","Lin"], to:["wall","lintels"]},

  // Wall -> Roof (wall section + labour + drawing)
  {id:"w_wall",   type:"Wall", from:["wall","wall_out"], to:["roof","wall_in"]},
  {id:"w_bl3",    type:"BL",   from:["wall","bl_w_out"], to:["roof","bl_r"]},
  {id:"w_d2",     type:"D",    from:["wall","draw_out"], to:["roof","draw2"], flavor:"info"},

  // Outer -> Roof (roof resources)
  {id:"w_tr",     type:"Tr", from:["IN","Tr"], to:["roof","trusses"]},
  {id:"w_rm",     type:"RM", from:["IN","RM"], to:["roof","roofmat"]},
  {id:"w_f",      type:"F",  from:["IN","F"], to:["roof","fasteners"]},
  {id:"w_sc",     type:"Sc", from:["IN","Sc"], to:["roof","scaffold"]},

  // Outputs to outer
  {id:"w_out_roofed", type:"Roofed", from:["roof","roofed"], to:["OUT","Roofed"]},
  {id:"w_out_blm",    type:"BL",     from:["mix","bl_m_out"], to:["OUT","BLm"]},
  {id:"w_out_bl",     type:"BL",     from:["roof","bl_r_out"], to:["OUT","BL"]},
  {id:"w_out_p",      type:"P",      from:["wall","peg_out"], to:["OUT","P"]},
  {id:"w_out_d",      type:"D",      from:["roof","draw2_out"], to:["OUT","D"], flavor:"info"},
  {id:"w_out_sc",     type:"Sc",     from:["roof","scaffold_out"], to:["OUT","Sc"]}
];

// Helpers
function portType(boxId, portKey){
  if (boxId === "IN") return OUTER.in.find(([k,t])=>k===portKey)?.[1];
  if (boxId === "OUT") return OUTER.out.find(([k,t])=>k===portKey)?.[1];
  const b = BOXES.find(x=>x.id===boxId);
  if(!b) return null;
  const all = [...b.inputs, ...b.outputs];
  return all.find(([k,t])=>k===portKey)?.[1] ?? null;
}

function portLabel(boxId, portKey){
  if (boxId === "IN" || boxId === "OUT") return portKey;
  const b = BOXES.find(x=>x.id===boxId);
  const all = [...b.inputs, ...b.outputs];
  const rec = all.find(([k,t])=>k===portKey);
  if(!rec) return portKey;
  const t = TYPES[rec[1]];
  return `${t.name}`;
}

function getBox(boxId){ return BOXES.find(b=>b.id===boxId); }

function outerPortPos(kind, key){
  // fixed positions
  if(kind==="IN"){
    const idx = OUTER.in.findIndex(([k,_])=>k===key);
    const x = 60;
    const y = 65 + idx*30;
    return {x,y};
  }
  if(kind==="OUT"){
    const idx = OUTER.out.findIndex(([k,_])=>k===key);
    const x = 1060;
    const y = 95 + idx*35;
    return {x,y};
  }
  return {x:0,y:0};
}

function boxPortPos(box, portKey, side){
  // side: "in" (left) or "out" (right)
  const ports = side==="in" ? box.inputs : box.outputs;
  const idx = ports.findIndex(([k,_])=>k===portKey);
  const n = ports.length;
  const pad = 18;
  const y = box.y + pad + (idx+0.5)*((box.h-2*pad)/n);
  const x = side==="in" ? box.x : (box.x + box.w);
  return {x,y};
}

function cubicPath(p1, p2, bend=0.35){
  const dx = (p2.x - p1.x);
  const c1 = {x: p1.x + dx*bend, y: p1.y};
  const c2 = {x: p2.x - dx*bend, y: p2.y};
  return `M ${p1.x} ${p1.y} C ${c1.x} ${c1.y}, ${c2.x} ${c2.y}, ${p2.x} ${p2.y}`;
}

const svg = document.getElementById("viz");

function el(name, attrs={}, parent=svg){
  const ns = "http://www.w3.org/2000/svg";
  const e = document.createElementNS(ns, name);
  for(const [k,v] of Object.entries(attrs)) e.setAttribute(k, v);
  parent.appendChild(e);
  return e;
}

let WIRE_ELEMS = new Map();
let BOX_ELEMS = new Map();
let SELECTED = null;

function render(){
  // Clear
  while(svg.lastChild && svg.lastChild.nodeName !== "defs"){
    svg.removeChild(svg.lastChild);
  }
  WIRE_ELEMS.clear(); BOX_ELEMS.clear();

  // Outer ports
  function drawOuterPorts(kind){
    const list = kind==="IN" ? OUTER.in : OUTER.out;
    list.forEach(([k,t], idx)=>{
      const p = outerPortPos(kind, k);
      el("rect", {x:p.x-30, y:p.y-12, width:60, height:24, rx:8, ry:8, class:"outerPort"});
      el("text", {x:p.x, y:p.y+4, "text-anchor":"middle", class:"outerPortTxt"}, svg).textContent = k;
      // small badge for type
      const ty = TYPES[t];
      const bg = ty.flavor==="info" ? "badgeBg2" : "badgeBg";
      el("rect", {x:p.x+36, y:p.y-10, width:22, height:20, rx:7, ry:7, class:bg});
      el("text", {x:p.x+47, y:p.y+4, "text-anchor":"middle", class:"badge"}, svg).textContent = ty.name;
    });
  }
  drawOuterPorts("IN");
  drawOuterPorts("OUT");

  // Wires first (so boxes sit on top)
  WIRES.forEach(w=>{
    const [sBox, sPort] = w.from;
    const [tBox, tPort] = w.to;
    let p1, p2;
    if(sBox==="IN") p1 = outerPortPos("IN", sPort);
    else if(sBox==="OUT") p1 = outerPortPos("OUT", sPort);
    else{
      const b = getBox(sBox);
      p1 = boxPortPos(b, sPort, "out");
    }
    if(tBox==="IN") p2 = outerPortPos("IN", tPort);
    else if(tBox==="OUT") p2 = outerPortPos("OUT", tPort);
    else{
      const b = getBox(tBox);
      p2 = boxPortPos(b, tPort, "in");
    }
    const d = cubicPath({x:p1.x, y:p1.y}, {x:p2.x, y:p2.y}, 0.42);
    const flavor = (w.flavor==="info" || TYPES[w.type]?.flavor==="info") ? "ac2" : "wire";
    const path = el("path", {d, class:`wire ${flavor}`, "marker-end":"url(#arrow)"});
    path.dataset.wireId = w.id;
    path.addEventListener("mouseenter", ()=>highlightWire(w.id));
    path.addEventListener("mouseleave", ()=>highlightWire(null));
    WIRE_ELEMS.set(w.id, path);

    // Label each wire near midpoint (subtle)
    const midX = (p1.x+p2.x)/2;
    const midY = (p1.y+p2.y)/2;
    const tname = TYPES[w.type].name;
    el("text", {x:midX, y:midY-6, "text-anchor":"middle", class:"nodeLabel", opacity:"0.55"}).textContent = tname;
  });

  // Boxes
  BOXES.forEach(b=>{
    const rect = el("rect", {x:b.x, y:b.y, width:b.w, height:b.h, rx:12, ry:12, class:"box"});
    rect.dataset.boxId = b.id;
    rect.addEventListener("click", ()=>selectBox(b.id));
    BOX_ELEMS.set(b.id, rect);

    el("text", {x:b.x + b.w/2, y:b.y + 24, "text-anchor":"middle", class:"boxtxt"}).textContent = b.label;

    // input ports labels
    b.inputs.forEach(([k,t], idx)=>{
      const p = boxPortPos(b,k,"in");
      el("text",{x:p.x-10,y:p.y+4,"text-anchor":"end",class:"porttxt"}).textContent = TYPES[t].name;
    });
    // output ports labels
    b.outputs.forEach(([k,t], idx)=>{
      const p = boxPortPos(b,k,"out");
      el("text",{x:p.x+10,y:p.y+4,"text-anchor":"start",class:"porttxt"}).textContent = TYPES[t].name;
    });
  });

  // Typecheck / wire validity coloring
  const issues = [];
  WIRES.forEach(w=>{
    const srcT = portType(w.from[0], w.from[1]);
    const tgtT = portType(w.to[0], w.to[1]);
    const ok = (srcT === w.type) && (tgtT === w.type);
    if(!ok){
      issues.push({wire:w.id, expected:w.type, src:srcT, tgt:tgtT});
      WIRE_ELEMS.get(w.id)?.classList.add("bad");
    } else {
      WIRE_ELEMS.get(w.id)?.classList.add("good");
    }
  });

  // Acyclicity check (simple: verify the box graph is acyclic)
  // Build adjacency on boxes only (ignore IN/OUT)
  const adj = new Map(BOXES.map(b=>[b.id, new Set()]));
  WIRES.forEach(w=>{
    const s = w.from[0], t = w.to[0];
    if(s!=="IN" && s!=="OUT" && t!=="IN" && t!=="OUT"){
      adj.get(s).add(t);
    }
  });
  function isDAG(){
    const temp = new Set(), perm = new Set();
    function visit(n){
      if(perm.has(n)) return true;
      if(temp.has(n)) return false;
      temp.add(n);
      for(const m of adj.get(n)){
        if(!visit(m)) return false;
      }
      temp.delete(n); perm.add(n);
      return true;
    }
    for(const n of adj.keys()){
      if(!visit(n)) return false;
    }
    return true;
  }
  const dag = isDAG();

  const pill = document.getElementById("typecheckPill");
  if(issues.length===0 && dag){
    pill.textContent = "Typecheck: OK ¬∑ Progress: acyclic";
    pill.className = "pill good";
  }else if(!dag){
    pill.textContent = "Typecheck: "+(issues.length? "errors":"OK")+" ¬∑ Progress: cycle!";
    pill.className = "pill bad";
  }else{
    pill.textContent = "Typecheck: "+issues.length+" error(s)";
    pill.className = "pill bad";
  }

  // default selection
  selectBox("wall", {quiet:true});
}

function highlightWire(wireId){
  for(const [id,el] of WIRE_ELEMS.entries()){
    el.classList.toggle("hi", id===wireId);
    el.classList.toggle("dim", wireId && id!==wireId);
  }
}

function selectBox(boxId, opts={}){
  SELECTED = boxId;
  for(const [id,el] of BOX_ELEMS.entries()){
    el.classList.toggle("selected", id===boxId);
  }
  // highlight wires incident to box
  const incident = new Set();
  WIRES.forEach(w=>{
    if(w.from[0]===boxId || w.to[0]===boxId) incident.add(w.id);
  });
  for(const [id,el] of WIRE_ELEMS.entries()){
    if(incident.size){
      el.classList.toggle("hi", incident.has(id));
      el.classList.toggle("dim", !incident.has(id));
    }else{
      el.classList.remove("hi","dim");
    }
  }
  if(!opts.quiet) renderInspector(boxId);
  else renderInspector(boxId);
}

function renderInspector(boxId){
  const b = BOXES.find(x=>x.id===boxId);
  const div = document.getElementById("inspector");
  if(!b){
    div.innerHTML = "<div class='note'>Select a box to inspect.</div>";
    return;
  }
  const showContracts = document.getElementById("btnContracts").classList.contains("on");
  const showTypes = document.getElementById("btnTypes").classList.contains("on");
  const showFormal = document.getElementById("btnFormal").classList.contains("on");

  const sigIn = b.inputs.map(([k,t])=>TYPES[t].name).join(" ‚äó ");
  const sigOut = b.outputs.map(([k,t])=>TYPES[t].name).join(" ‚äó ");

  let html = `
    <div style="display:flex;align-items:flex-start;justify-content:space-between;gap:10px">
      <div>
        <div style="font-weight:800;font-size:14px;letter-spacing:.2px">${b.label}</div>
        <div class="small" style="margin-top:2px">morphism signature</div>
      </div>
      <div class="pill">${b.id}</div>
    </div>
    <div class="k" style="margin-top:10px">
      <span style="color:#e2e8f0"><strong>${b.id}</strong></span> : <span style="color:#cbd5e1">${sigIn}</span> ‚Üí <span style="color:#cbd5e1">${sigOut}</span>
    </div>
  `;

  if(showTypes){
    html += `<div class="hr"></div><div class="small">Port types</div><div class="k" style="max-height:170px">`;
    html += `<strong>Inputs</strong>\n`;
    b.inputs.forEach(([k,t])=>{
      html += `‚Ä¢ ${k}: ${TYPES[t].name} ‚Äî ${TYPES[t].desc}\n`;
    });
    html += `\n<strong>Outputs</strong>\n`;
    b.outputs.forEach(([k,t])=>{
      html += `‚Ä¢ ${k}: ${TYPES[t].name} ‚Äî ${TYPES[t].desc}\n`;
    });
    html += `</div>`;
  }

  if(showContracts){
    html += `<div class="hr"></div><div class="small">Contract (assume / guarantee)</div><div class="k">`;
    html += `<strong>Assume</strong>\n`;
    b.contract.assume.forEach(s=>{ html += `‚Ä¢ ${s}\n`; });
    html += `\n<strong>Guarantee</strong>\n`;
    b.contract.guarantee.forEach(s=>{ html += `‚Ä¢ ${s}\n`; });
    html += `</div>`;
  }

  if(showFormal){
    html += `<div class="hr"></div><div class="small">How it composes</div>
      <div class="k">
        In the <em>wiring-operad</em> view, this box is just one of the ‚Äúinner‚Äù morphisms; the big diagram is a single term
        Œ¶ : (mix, set, wall, roof) ‚Üí build. An algebra H (a strict SMC) sends Œ¶ to a function H(Œ¶) that composes these morphisms into the outer one.
      </div>
    `;
  }

  div.innerHTML = html;
}

function renderFormalism(){
  const blk = document.getElementById("formalBlock");
  const txt = `
(1) Syntax (an operad term / wiring diagram)

Fix a set of types œÑ = {BL,S,C,W,M,P,D,L,B,Lin,Wall,Tr,RM,F,Sc,Roofed}.
A ‚Äúbox‚Äù (interface) is a signed œÑ-typed finite set:  t = (t‚Åª, t‚Å∫).

Define the four process-boxes (interfaces):
  Mix  : (BL ‚äó S ‚äó C ‚äó W) ‚Üí (BL ‚äó M)
  Set  : (BL ‚äó P ‚äó D)     ‚Üí (BL ‚äó L ‚äó P ‚äó D)
  Wall : (BL ‚äó B ‚äó Lin ‚äó M ‚äó L ‚äó P ‚äó D) ‚Üí (BL ‚äó Wall ‚äó P ‚äó D)
  Roof : (BL ‚äó Wall ‚äó Tr ‚äó RM ‚äó F ‚äó Sc ‚äó D) ‚Üí (BL ‚äó Roofed ‚äó Sc ‚äó D)

The whole plan is one acyclic wiring term:
  Œ¶ : (Mix, Set, Wall, Roof) ‚Üí Build
whose port-attachments are exactly the picture / wiring-table.

(2) Semantics (an algebra / your chosen SMC)

Choose a strict symmetric monoidal category ùì° modelling ‚Äúresource behaviour‚Äù:
  ‚Ä¢ objects: resource-types (BL, M, Wall, ‚Ä¶)
  ‚Ä¢ morphisms: concrete processes (mix mortar, set-out, lay bricks, install roof)
  ‚Ä¢ ‚äó : parallel availability / juxtaposition of resources
Then an algebra H : W_œÑ ‚Üí Set (equivalently: a strict SMC with œÑ-labelled objects) sends Œ¶ to a function:
  H(Œ¶) : Hom(Mix) √ó Hom(Set) √ó Hom(Wall) √ó Hom(Roof) ‚Üí Hom(Build)

Given concrete process-morphisms (mix, set, wall, roof), the composite is:
  build := H(Œ¶)(mix, set, wall, roof).

(3) ‚ÄúPhysics + project thinking‚Äù as contracts

Optionally annotate each process with a (static) contract R ‚äÜ In √ó Out.
Contracts compose by existentially quantifying internal wires, i.e. ‚Äúhide intermediates‚Äù:
  R_build(y_in, y_out)  ‚áî  ‚àÉ(internal outputs) . (R_mix ‚àß R_set ‚àß R_wall ‚àß R_roof ‚àß wiring-equalities)
This is the same pullback-image recipe as the W‚ÜíCat contract algebra: you only see what can occur at the boundary.
`.trim();
  blk.textContent = txt;
}

function renderWiringTable(){
  const k = document.getElementById("wiringTable");
  // Build a human-readable mapping of each input port to its source.
  const rows = [];
  function srcOf(toBox, toPort){
    const w = WIRES.find(w=>w.to[0]===toBox && w.to[1]===toPort);
    if(!w) return "‚Äî";
    const [sb, sp] = w.from;
    const src = (sb==="IN") ? `IN.${sp}` : `${sb}.${sp}`;
    return `${src} : ${TYPES[w.type].name}`;
  }
  BOXES.forEach(b=>{
    rows.push(`== ${b.label} (${b.id}) ==`);
    b.inputs.forEach(([p,t])=>{
      rows.push(`  ${b.id}.${p} ‚Üê ${srcOf(b.id,p)}`);
    });
    rows.push("");
  });
  rows.push("== Outputs to boundary ==");
  OUTER.out.forEach(([kout,t])=>{
    const w = WIRES.find(w=>w.to[0]==="OUT" && w.to[1]===kout);
    const src = w ? ((w.from[0]==="IN") ? `IN.${w.from[1]}` : `${w.from[0]}.${w.from[1]}`) : "‚Äî";
    rows.push(`  OUT.${kout} ‚Üê ${src} : ${TYPES[t].name}`);
  });

  k.textContent = rows.join("\n");
}

document.getElementById("btnContracts").addEventListener("click", (e)=>{
  e.target.classList.toggle("on");
  renderInspector(SELECTED);
});
document.getElementById("btnTypes").addEventListener("click", (e)=>{
  e.target.classList.toggle("on");
  renderInspector(SELECTED);
});
document.getElementById("btnFormal").addEventListener("click", (e)=>{
  e.target.classList.toggle("on");
  renderInspector(SELECTED);
});

render();
renderFormalism();
renderWiringTable();
</script>
</body>
</html>
